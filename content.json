{"meta":{"title":"大风扇","subtitle":"largefan","description":"正在学习中！！！","author":"largefan","url":"https://largefan.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-09-15T04:00:00.000Z","updated":"2023-02-03T01:42:43.218Z","comments":false,"path":"about/index.html","permalink":"https://largefan.github.io/about/index.html","excerpt":"","text":"联系方式 ● 手机：13005683116 ● Email：largefan@qq.com ● 微信：Largefan 个人信息 林子彬 | 男 | 2000-07-04 广东科技学院 | 计算机专业 | 大专 技术博客：https://largefan.github.io/ Github：https://github.com/largefan 专业技能 熟练运用 HTML+CSS+JavaScript+es6，写出静态页面及动态页面。 熟悉Git的基本操作 熟悉 微信小程序 ，前端页面的开发。 熟悉 vue2 前端开发框架以及生态工具Vuex、Vue Router、Axios 了解 node.js,用过Express写接口，了解前后端身份认证原理 熟悉 Ps、pr 的基本使用。 项目经验仿天猫网站主要功能：网站显示 商品分类 和 商品信息，标签栏切换、浮动广告、商品秒杀活动倒计时、手风琴效果、用户注册验证。 书城小程序主要功能：实现 商品列表页 和 详情页的展示、轮播图、加入和清空和结算购物车、登录。 PS制作导航栏利用PS软件制作出 首页导航栏 和 其他导航栏。 自我介绍我性格积极、乐观，对工作认真负责，能快速适应工作环境，并且能在实际工作中不断学习，不断完善自我，且有良好的团队精神和一定抗压力能力。"},{"title":"archives","date":"2021-10-24T16:00:00.000Z","updated":"2022-08-30T12:27:27.906Z","comments":true,"path":"archives/index.html","permalink":"https://largefan.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://largefan.github.io/categories/index.html","excerpt":"","text":""},{"title":"ES6简介","date":"2022-06-08T16:10:00.000Z","updated":"2022-09-12T10:19:20.865Z","comments":true,"path":"artitalk/ES6简介.html","permalink":"https://largefan.github.io/artitalk/ES6%E7%AE%80%E4%BB%8B.html","excerpt":"","text":"一、ES6简介 JavaScript由ECMAScript、DOM、BOM这三大部分组成。 由于ES6发布于2015年，所以叫 “ ES2015 ” 或 “ ECMAScript2015 ”。这两种叫法都是指ES6。 问题 1：为什么ES12都出来了还叫ES6？ 因为ES5到ES6是一次大的版本更新。ES7-ES12是小更新，所以笼统称为ES6。 问题 2 ：解决低版本浏览器不支持ES6语法 实际开发不需要我们手动配置Babel环境了，因为VUE或React等脚手架工具会帮我们配置好！ 问题 3 ：现在主流浏览器 Chrome、Edge、Firefox等浏览器都已经支持绝大部分的ES6语法了。 也就是说不需要Babel编译，就可以直接在浏览器中运行ES6代码。"},{"title":"留言","date":"2021-10-01T02:11:28.000Z","updated":"2022-08-30T12:27:42.134Z","comments":false,"path":"comments/index.html","permalink":"https://largefan.github.io/comments/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://largefan.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://largefan.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://largefan.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-02-03T01:39:39.744Z","updated":"2023-02-03T01:39:39.744Z","comments":false,"path":"List/gallery/index.html","permalink":"https://largefan.github.io/List/gallery/index.html","excerpt":"","text":"one 美食 two 风景"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2023-02-02T18:47:08.248Z","comments":false,"path":"List/movies/index.html","permalink":"https://largefan.github.io/List/movies/index.html","excerpt":"","text":"必杀技"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-08-27T05:00:48.828Z","comments":false,"path":"List/music/index.html","permalink":"https://largefan.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2022-09-12T17:54:44.515Z","comments":false,"path":"List/gallery/fengjing/index.html","permalink":"https://largefan.github.io/List/gallery/fengjing/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2022-08-27T05:49:09.229Z","comments":false,"path":"List/gallery/meiren/index.html","permalink":"https://largefan.github.io/List/gallery/meiren/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6模块化","slug":"es6模块化","date":"2022-06-30T16:04:20.000Z","updated":"2023-02-03T01:23:38.601Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://largefan.github.io/posts/11.html","excerpt":"","text":"一、导出语句导出语句（即暴露出去） 语法： export default 变量名; import 变量名 from 路径; ①export default —只能导出一个内容，这个内容可以是变量、函数、对象、类等。1. 导出变量例子1：（导出一个变量或值） 方式①：变量 const foo = \"小白\"; export default foo; 方式②：值 export default \"小白\"; 注意： ① 在HTML文件中使用模块化语法，必须在script上加上 type=\"module\"；否则会报错。 ② 一个js文件只能用一次export default 2.导出函数例子2：（导出一个函数） // 导出方式1： function foo(){ console.log(\"方式111导出的\"); } export default foo; // 导出方式2： export default function(){ console.log(\"方式222导出的\"); } // 导出方式3： export default function foo(){ console.log(\"方式333导出的\"); } // 导出方式4： const foo = function foo(){ console.log(\"方式444导出的\"); } export default foo; 3. 导出对象//例3：（导出一个对象） // 导出方式1： const person = { name:\"jack\", age:22, demo:\"导出方式111\" } export default person; // 导出方式2： export default{ demo:\"导出方式222\" }; 4. 导出类//例4：（导出一个类） // 导出方式1： class person{ constructor(name){ this.name = name; } sayName(){ console.log(this.name); } } export default person; // 导出方式2： export default class person{ constructor(name){ this.name = name; } sayName(){ console.log(this.name) } } ②export1.导出多个变量① 导出多个变量： // 导出方式1： export const red = \"红色\"; export const green = \"绿色\"; export const blue = \"蓝色\"; // 导出方式2： const red = \"红色\"; const green = \"绿色\"; const blue = \"蓝色\"; export {red,green,blue}; 2.导出多个函数②导出多个函数 // 导出方式1： export function red(){ console.log(\"红色\"); } export function green(){ console.log(\"绿色\"); } export function blue(){ console.log(\"蓝色\"); } 因为export导出的是一个集合，所以为了与export导出内容的结构一致11对应，因此必须在import后面加上{}。只要用了export,导入时都要加{} 注意：如果导出的是对象，那么export {red,green,blue};等价于export {red:red,green:green,blue:blue}; 二、导入语句导入语句: 语法： import {变量1,变量2,...,变量n} from 路径; 1. 导入（import）时可 重新命名① export default：（直接在import后面使用新的变量名。） //foo.js const red = \"红色\" export default red; //bar.js import myRed from \"./foo.js\"; console.log(myRed); ② export：（用as关键字来重新命名。） //foo.js export const red = \"红色\"; //bar.js import {red as myRed} from \"./foo.js\"; console.log(myRed); 三、深入了解1. 省略后缀名在import导入时路径中的后缀名可以省略 注意： 省略仅限于webpack、vue、react等；在HTML中引入了一个省略后缀文件是行不通的！！！ 即import foo from \"./foo\" 2.export default 和 export 可以混合使用//foo.js const red =\"红色\" export default red; export const black =\"黑色\" //bar.js import red,{black} from \"./foo.js\"; console.log(red); console.log(black); 3. 模块化中的路径和图片路径不一样！import foo from \"./foo.js\"---这个是从当前文件所在目录导入foo.js，模块是自定义的，使用这种导入方式。 import foo from \"foo.js\"---这个是在node_module导入foo.js，模块是npm安装的，使用这种导入方式。 4.解决export default不能使用解构赋值方法；因为{}已经分给export了！//foo.js export default{ name:\"jack\", age:\"24\" }; //bar.js import foo from \"./foo\"; const {name,age} = foo; console.log(name); console.log(age); 5.模块化优点：可读性和可维护性强，性能更好，集中到一个文件，只需发起一次http请求。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://largefan.github.io/tags/ES6/"}]},{"title":"前后端的身份认证--JWT认证机制原理","slug":"JWT认证机制","date":"2022-06-29T06:30:00.000Z","updated":"2023-02-03T01:22:56.232Z","comments":true,"path":"posts/17.html","link":"","permalink":"https://largefan.github.io/posts/17.html","excerpt":"","text":"一、了解 Session 认证的局限性： Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。 注意： 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。 二、什么是 JWT ？ JWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。 JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。 Payload部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。 Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性。 三、 JWT 的工作原理： 用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。 四、总结 先在页面输入用户名和密码，点击登录，登录成功后自动调用 jwt.sign() 方法 加密 生成token，然后把token发送给客户端浏览器。 当客户端登录成功之后会跳转 首页页面 ，首页页面 就会向服务器发送刚刚保存在浏览器中的token发送出去，服务器就会用 expressJWT()方法 解密 即解析，然后把解析出来的jwt.sign({username:userinfo.username},secretKey,{expiresIn:’30s’})里面的username的值赋给req.user然后就可以，使用 req.user 获取用户信息，然后可用res.send（req.user）返回用户名给首页了 有访问权限接口 意思是：这个接口(网页)可以获取服务器中的用户名、密码等信息。（即登录了） 无访问权限接口 意思是：这个接口(网页)不能或不需要获取服务器中的用户名、密码等信息（没有登录）。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://largefan.github.io/tags/Node/"}]},{"title":"Express-写接口","slug":"Express-写接口","date":"2022-06-28T03:10:10.000Z","updated":"2023-02-03T01:34:51.189Z","comments":true,"path":"posts/15.html","link":"","permalink":"https://largefan.github.io/posts/15.html","excerpt":"","text":"一、创建基本的服务器： 二、 创建 API 路由模块： 三、编写 GET 接口： 四、编写 POST 接口：","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://largefan.github.io/tags/Node/"}]},{"title":"数据库语法","slug":"数据库语法","date":"2022-06-27T19:41:00.000Z","updated":"2022-09-12T14:14:49.870Z","comments":true,"path":"posts/16.html","link":"","permalink":"https://largefan.github.io/posts/16.html","excerpt":"","text":"查询数据（select） 、插入数据（insert into） 、更新数据（update） 、删除数据（delete） ; where 条件、and 和 or 运算符、order by 排序、count(*) 函数 -- 一、select、insert into、update、delete -- * 把 users 表中所有的数据查询出来 -- select * from users -- 从 users 表中把 username 和 password 对应的数据查询出来 -- select username,password from users -- 向 users 表中，插入新数据：username的值为tony stark password的值为 098123 -- insert into users(username,password) values('tony stark','098123') -- select * from users -- 将 id为4的用户密码，更新成 888888 -- update users set password='888888' where id=4 -- 更新id为2的用户，把用户密码更新admin123 同时，把用户的状态更新为 1 -- update users set password='admin123',status=1 where id=2 -- select * from users -- 注意：千万不要忘记提供 where 条件，否则将导致误删整张表的数据！！！ -- 删除 users 表中，id为4的用户 -- delete from users where id=4 -- select * from users -- 二、演示 where 子句的使用: -- 查询 users表 中 状态为1的数据 -- select * from users where status=1 -- 查询 users表 中 id大于等于2的数据 -- select * from users where id&gt;=2 -- 查询 users表 中 用户名不等于ls的数据 -- select * from users where username&lt;&gt;'ls' -- 查询 users表 中 用户名不等于ls的数据(跟上面那一条语句，等价的) -- select * from users where username!='ls' -- 三、and(&amp;&amp;与) or(||或) =&gt; AND OR -- 需要满足两个条件才能被查询到！ -- select * from users where status=0 and id&lt;3 -- 在users表中只要满足status=1 或 username='zs'其中一个条件，则会被成功查询到 -- select * from users where status=1 or username='zs' -- 四、1.order by status asc （表示升序,不写asc，默认是升序排序）;2.order by id desc(表示降序) 3.多重排序 -- 1.对users表中的数据，按照status字段进行------升序排序 -- select * from users order by status -- 上面语句与下面语句是 相等 的（写不写asc都行） -- select * from users order by status asc -- 2.按照 id 对结果进行降序的排序 desc ------表示降序排序 -- select * from users order by id desc -- 3.多重排序 -- 对users表中的数据，先按照status进行降序排序，再按照username字母的顺序,进行升序排序---asc可省略 -- 因为字母x在字母z的前面，所以username asc之后名为xh在zs之前 -- select * from users order by status desc,username asc -- 五、count(*) 函数用于查询结果的总数据条数; as 可以把查询出来的列名称（即count(*) ）改为其他名字 -- 使用count(*) 来统计users表中，状态为0的用户总数量 -- select count(*) from users where status=0 -- 使用 as 关键字给列(字段)改名字 -- select count(*) as total from users where status=0 -- select username as name,password as upwd from users","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://largefan.github.io/tags/MySQL/"}]},{"title":"github上手","slug":"github上手","date":"2022-06-18T07:00:00.000Z","updated":"2022-08-30T11:26:17.155Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://largefan.github.io/posts/10.html","excerpt":"","text":"一、上手github1. git clone 远程库链接 ，把文件克隆下来。 2.创建分支，把代码文件复制进克隆文件夹，然后add和commit，然后合并分支，然后可以把旧分支删除。 3.git push 别名（远程地址） 分支，然后会弹出验证授权，确认后则上传github成功。 4.如代码更新了，则用 git pull 远程库地址别名 远程分支名，即可更新工作区代码。 二、遇到都问题总结：1.解决 git clone 无法获取本地颁发者证书 问题： 解决方法：输入命令即可：git config –global http.sslVerify false 2. 不要把代码文件里的 .git 复制进 git clone 克隆文件夹里面！只需创建分支，把代码文件提交进本地库，然后提交远程库。 3.git pull（当远程仓库有更新，可用pull进行更新，但它会直接更新到工作区把旧的文件覆盖掉！所以我们用fetch更新到本地仓库 再用 diff对比区别 ，没问题在合并过来。） 4. git remote -v 这个命令可以简化操作： 例：push的时候 远程库链接 可以换成 origin 来代替URL 5.新手在github上一般点击 Download ZIP 下载文件,此方法只会下载当前最新版本的文件，其中的版本历史和记录不会下载，也就是说压缩文件里面没有.git文件夹！ 6.分支不明确导致的问题： 7.再次说明！！！！！ 如果你想要把代码添加到github，就必须上github把仓库下载下来，在把写好代码拉进来即可。 一、在github上创建仓库，然后在桌面创建文件夹右键打开Bash，然后git clone 仓库地址 把文件下载下来。 二、把写好的文件代码 复制拉进来 然后执行常用命令①②③④ 就可以把代码添加到github上了 三、如果你在github上修改了代码 则执行⑤命令 把github上的代码 更新 到本地了","categories":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/categories/Git/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://largefan.github.io/tags/Github/"}]},{"title":"Git实操","slug":"Git实操","date":"2022-06-18T06:30:15.000Z","updated":"2023-02-03T01:26:38.241Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://largefan.github.io/posts/9.html","excerpt":"","text":"①git init： 拓展1：git status： 第一次查看状态，提示：工作区没有任何文件 拓展2：（用vim）：新增txt文件：1.输入：Vim lzb.txt 2.输入内容：aaa bbb ccc 3.按esc键 4.按SHIFT + : 然后wq保存 5.回车即成功创建lzb.txt 拓展3： 第二次查看状态，提示： 检测到未追踪的文件（即还未git add） git status ②添加暂存区：git add lzb.txtgit add lzb.txt 第三次查看状态，提示：检测到暂存区有新文件（即还未③git commit -m “日志信息” 文件名） ③提交本地库：(文件名不写则全部提交)git commit -m “日志信息” 文件名 此时第四次查看状态，提示：没有文件需要提交了 拓展4（用vim）：修改文件 lzb.txt1.输入：$ vim lzb.txt 2.按 i 键才能修改。 3.输入以下内容： 4.按esc 5.按SHIFT + ： 6.wq 7.回车即修改成功。 拓展5： 查看状态,提示：检测到工作区有文件被修改！ 然后需要我们 重新 添加暂存区 和 提交本地库 ! 小技巧：把 add 和 commit 合在一起写，这样就可以从 工作区 跳到 本地版本库 了! 从下图，查看状态可看出已经没有文件需要提交了！","categories":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/tags/Git/"}]},{"title":"Git的常用命令","slug":"Git的常用命令","date":"2022-06-18T06:12:31.000Z","updated":"2023-02-03T01:26:18.552Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://largefan.github.io/posts/8.html","excerpt":"","text":"一、Git的常用命令 命令名称 作用 git config –global user.name 用户名 设置用户签名 git config –global user.email 邮箱 设置用户签名 ①git init 初始化本地库 git status 查看本地库状态 ②git add 文件名 git add . 意思是把所有文件添加到暂存区 添加到暂存区 ③git commit -m “日志信息” 文件名 提交到本地库 ④git push 别名（远程地址） 分支 本地库提交到 github ⑤当 GitHub 平台修改了代码 则可用 git pull 更新到本地库 即会覆盖本地库代码！ 版本控制 作用 git reflog 查看版本信息 git log 查看版本详细信息 git reset –hard 版本号 版本切换 cat lzb.txt(文件名) 查看版本内容 注意： 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。 这里设置用户签名和将来登录GitHub（或其他代码托管中心）的账号没有任何关系！ 二、分支命令 命令名称 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 git branch -d 分支名 删除分支（非常确定要删除，则该分支用大写 -D） git checkout -b 要创建的分支名 创建分支并马上切换到新分支 三、.gitignore—文件解说 命令 作用 touch .gitignore 处理在实际开发中不需要提交的文件 在.gitignore里面写入图片名字，即可让git不在追踪此图片。 查看是否成功命令：git status(未提示图片名字则成功，反之失败) 四、GitHub命令操作 命令 作用 git clone 链接(远程地址 ) 将远程仓库的内容克隆到本地 git remote -v 查看本地仓库和远程仓库有哪些联系 git remote add 别名 远程地址 起别名 git push 别名 分支 推送本地分支上的内容到远程仓库 git fetch 与diff配合更新本地，不会改变工作区，因为它是添加到本地仓库。 git diff 远程仓库名/分支名 此符号 / 照写。用于查看 远程仓库和分支的区别。 git pull 远程库地址别名 远程分支名 如果远程仓库和分支没问题，则用pull添加到工作区，如不使用fetch和diff命令，直接pull则会直接覆盖掉工作区。 五、vim–命令1.新增（或修改）txt文件：$ Vim lzb.txt 2.esc退出编辑状态； yy复制 p粘贴 3.按SHIFT + : 然后wq保存 4.按 i 键才能修改 5.查看文件：cat 文件名（即lzb.txt）","categories":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/tags/Git/"}]},{"title":"Git分支与版本控制","slug":"Git分支与版本控制","date":"2022-06-18T04:30:13.000Z","updated":"2023-02-03T01:26:26.662Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://largefan.github.io/posts/7.html","excerpt":"","text":"一、分支是什么？ 分支可以简单理解为副本，一个分支就是一个单独的副本。（即在副本上操作，不动原文件）优点： 同时并行推进多个功能开发，提高开发效率。 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。 二、分支-命令操作 创建分支：git branch 分支名 查看分支：git branch -v 切换分支：git checkout 分支名** *表示当前所在的分区 修改分支里的文件，需要重新添加暂存区和提交本地库。 三、注意：不要把历史版本和分支搞混淆了四、版本控制 命令如下： git reflog：查看版本信息 git log：查看版本详细信息 切换版本： git reset –hard 版本号 查看版本内容： **cat lzb.txt(文件名) **","categories":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/tags/Git/"}]},{"title":"Git概述","slug":"Git概述","date":"2022-06-18T04:23:11.000Z","updated":"2023-02-03T01:26:31.520Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://largefan.github.io/posts/6.html","excerpt":"","text":"一、Git是什么？ Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。 Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。 二、什么是版本控制？ 版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。 版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。 三、版本控制分类： 集中式版本控制工具：CVS、SVN(Subversion)、VSS…… 优点：可以看到项目中的其他人在做些什么，管理员也可掌控每个开发者的权限，比在各个客户端上维护本地数据库来得轻松容易。 缺点：服务器坏了一天，那么这一天谁都无法提交更新。 分布式版本控制工具：Git、Mercurial、Bazaar、Darcs…… 分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷 服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的） 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）","categories":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/tags/Git/"}]},{"title":"Node命令与快捷键总结","slug":"Node-命令与快捷键","date":"2022-06-11T00:10:10.000Z","updated":"2023-02-03T01:10:01.602Z","comments":true,"path":"posts/14.html","link":"","permalink":"https://largefan.github.io/posts/14.html","excerpt":"","text":"一、终端中的快捷键：① 使用 ↑键，可以快速定位到上一次执行的命令② 使用 tab键，能够快速补全路径③ 使用 esc键，能够快速清空当前已输入的命令④ 输入 cls命令，可以清空终端二、npm与包：1. 查看npm包管理工具的版本号：npm -v 2. 项目中安装包的命令：npm install 包的完整名称 （简写：npm i 包的名称） 3. 项目中安装指定版本命令：npm i moment@2.22.2 4. 创建package.json: npm init -y 5. 一次性安装package.json里面记录的包： npm i 6. 卸载包：npm uninstall 7. 安装到dependencies节点：npm install 包的完整名称 8. 安装到devDependencies节点：npm install 包的完整名称 –save-dev(简写：npm i 包的完整名称 -D) 9. nrm工具（方便切换下包的镜像源）： 下载nrm：npm i nrm -g 查看所有镜像源：nrm ls 切换淘宝镜像：nrm use taobao 10. 全局包： 安装：npm i 包名 -g 卸载：npm uninstall 包名 -g 11. i5ting_toc(用来转换.md文件)： 首先全局安装这个工具：npm install -g i5ting_toc 调用i5ting_toc，实现 md 转换 html 功能：i5ting_toc -f md文件路径 -o 12. 在终端登录账号：（注意：镜像源必须是npm） 1.npm login 2.输入用户名、密码、邮箱后，即可登录成功 13. 在终端发布包： 1.将终端切换到要发布的包根目录 2.npm publish 3.删除已发布的包：npm unpublish 包名 –force 三、路由 Express 的安装：npm i express@4.17.1 nodemon的安装（自动重启项目工具）：npm install -g nodemon 1. 用法：nodemon app.js（ app.js为要启动的文件名字） 四、解决跨域问题： 安装cors中间件：npm install cors 使用方法：const cors = require(‘cors’) ，然后调用 app.use(cors())","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://largefan.github.io/tags/Node/"}]},{"title":"var-let-const","slug":"var-let-const","date":"2022-06-09T04:00:10.000Z","updated":"2023-02-03T01:28:05.035Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://largefan.github.io/posts/13.html","excerpt":"","text":"一、var(弊端非常多) 无块级作用域 说明：即在大括号中使用var声明变量，我们在大括号外面也访问的到。 if (true) { var a = \"可被外面访问\"; } console.log(a); //输出：可被外面访问 存在变量提升 console.log(a); var a = \"存在变量提升\"; //输出：undefined 等价于下面： /*即把 var a; 提升到顶部了，但不知道a是什么，所以返回 undefined。*/ var a; console.log(a); a = \"存在变量提升\"; //输出：undefined 二、let（用于声明变量，有4个特点。） 有块级作用域 let a = \"大风扇\"; if(true){ let a = \"小风扇\"; console.log(a); } console.log(a); // 小风扇 // 大风扇 同一代码块中，不允许重复声明 if(true){ let a = \"报错了，叼毛\"; let a = \"报错了，叼毛\"; console.log(a); } // Uncaught SyntaxError: Identifier 'a' has already been declared 但这个变量可以被重新赋值： if(true){ let a = \"叼毛一号\"; a = \"叼毛二号\"; console.log(a); } // 输出：叼毛二号 不存在变量提升 console.log(a); let a = \"叼毛一号\"; // Uncaught ReferenceError: Cannot access 'a' before initialization 不会成为window的属性 let a = \"2022\"; let fn = function(){ console.log(2022); }; console.log(window.a); window.fn(); // undefined // Uncaught TypeError: window.fn is not a function 说明：ES6之前，在全局作用域中，使用var声明的变量会成为window对象的属性。 例： var a = 2022; var fn = function(){ console.log(2022); }; console.log(window.a); window.fn(); //2022 //2022 三、const（用于声明常量，同样有4个特点） 有块级作用域 不允许重复声明 不存在变量提升 不会成为window的属性 3.1 常量不允许重新赋值，“ 基本类型 “ 声明后是不允许修改该值的：const PI = 3.1415926; PI = 3.14; console.log(PI); // Uncaught TypeError: Assignment to constant variable. 3.2 ” 引用类型 “ 也不能修改该值，但可以修改它属性的值： 正确写法：用const是保证person指针不能改变，但person对象 属性的值是可以修改的。 const person = { name:\"Jack\", age:22 }; person.name = \"LiHua\"; console.log(person); // Object { name: \"LiHua\", age: 22 } 错误写法：如改变person指针，让person指向一个新对象，则会报错。 const person = { name:\"Jack\", age:22 }; person = { name:\"large fan\", age:20 } console.log(person); // Uncaught TypeError: Assignment to constant variable. 3.3 const声明 数组：const arr = [\"red\",\"green\",\"blue\"]; arr[0] = \"orange\"; console.log(arr); // Array(3) [ \"orange\", \"green\", \"blue\" ] 三、暂时性死区说明：在 ” {} “括起来的块级作用域中，存在一个” 死区 “，它开始于函数开头，终止与变量声明所在的那一行；在这个区域中，我们无法访问let和const声明的变量，这个” 死区 “称为 ” 暂时性死区 “。 function fn(){ console.log(a); let a = 2022; } fn(); // Uncaught ReferenceError: Cannot access 'a' before initialization 暂时性死区是随着ES6中的let和const的引入而引入的。 &gt;&gt;在ES5中是没有暂时性死区这种说法的！ &gt;&gt;function fn(){ console.log(a); var a = 2022; &gt;&gt;} &gt;&gt;fn(); &gt;&gt;// undefined &gt;&gt;&gt;这个例子中不存在暂时性死区，console会沿着作用域链往上寻找。 &gt;&gt;&gt;let a = 2022; &gt;&gt;&gt;{ console.log(a); &gt;&gt;&gt;} &gt;&gt;&gt;// 2022","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://largefan.github.io/tags/ES6/"}]},{"title":"ES6简介","slug":"ES6简介","date":"2022-06-08T16:10:00.000Z","updated":"2023-02-03T01:23:44.250Z","comments":true,"path":"posts/12.html","link":"","permalink":"https://largefan.github.io/posts/12.html","excerpt":"","text":"一、ES6简介 JavaScript由ECMAScript、DOM、BOM这三大部分组成。 由于ES6发布于2015年，所以叫 “ ES2015 ” 或 “ ECMAScript2015 ”。这两种叫法都是指ES6。 问题 1：为什么ES12都出来了还叫ES6？ 因为ES5到ES6是一次大的版本更新。ES7-ES12是小更新，所以笼统称为ES6。 问题 2 ：解决低版本浏览器不支持ES6语法 实际开发不需要我们手动配置Babel环境了，因为VUE或React等脚手架工具会帮我们配置好！ 问题 3 ：现在主流浏览器 Chrome、Edge、Firefox等浏览器都已经支持绝大部分的ES6语法了。 也就是说不需要Babel编译，就可以直接在浏览器中运行ES6代码。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://largefan.github.io/tags/ES6/"}]},{"title":"前端面试题","slug":"面试","date":"2021-10-09T16:00:00.000Z","updated":"2022-08-28T07:01:40.965Z","comments":true,"path":"posts/100.html","link":"","permalink":"https://largefan.github.io/posts/100.html","excerpt":"","text":"HTML51、HTML5的新特性？ 1、语义化标签，比如header、footer、nav、aside、article、section 2、音视频，比如audio、video 3、画布canvas、矢量图svg 3、画布，canvas的api有getContext、fillStyle、fillRect等 4、本地存储localStorage、sessionStorage 5、web worker2、语义化的好处？ 1、代码分块清晰，便于维护 2、页面结构清晰，便于浏览器。搜索引擎解析 3、利于搜索引擎的爬取，利于SEO3、canvas的常用api有哪些？ getContext：返回一个指定canvas的绘画环境对象 beginPath：开始绘制 moveTo：移动画笔位置 lineTo：用来画线段 stroke：用来实施绘制的操作 lineStyle：设置线段的样式 closePath：结束绘制4、web worker有什么作用？应用场景有哪些？开启一个子线程，且子线程的操作不受线程的影响 大数据处理 耗费时间较长的操作5、浏览器本地缓存localStorage与sessionStorage的区别？ 生命周期不同：前者一直存在浏览器，除非用户手动清除，后者生命周期结束于浏览器或者tab页的关闭 CSS31、有哪些新特性呢？flex、animation、transform、border-radius、box-shadow、opacity 2、背景毛玻璃的效果如何实现呢？filter：blur() 3、position有哪几种呢？ static：默认 relative：相对于自身 absolute：相对于最近的一个非static的祖先级元素进行定位 fixed：相对于屏幕窗口进行定位 sticky：用来实现吸顶效果4、如何自己实现跟position：sticky的效果？使用getBoundingClientRect或者IntersectionObserver计算指定元素位置，到达一定距离更改指定元素定位为fixed，从而实现sticky的效果5、重绘回流是什么呢？文章链接6、怎么降低重绘回流的次数呢？文章链接7、flex布局如何更改主轴方向？设置flex-direction样式属性8、flex布局如何允许换行呢？设置flex-wrap样式属性9、flex布局实现水平垂直据居中？设置justify-content和align-items都为center10、flex：1的原理是什么呢？flex-grow 、flex-shrink 、flex-basis这三个样式的合集，全写状态为flex:0 1 auto，简写为flex: 111、rem与em的区别是什么呢？ rem：相对于标签的font-size去决定大小，例如html标签font-size为14px，则2rem === 28px em：相对于自身的font-size去决定大小，自身没有font-size则继承祖先级元素的font-size JavaScript1、原型链是什么呢？有什么作用吗 原型链：原型链是一条对象隐式原型不断往上指向的一条指向链，尽头是Object的隐式原型，也就是null 作用：构造函数原型上的东西可以让实例们共享，从而节省了空间2、闭包是什么？有什么优缺点闭包是一个能让函数外部访问到函数内部的一个函数 优点是：延长函数内部变量的寿命，使函数外部能访问到函数内部 缺点是：滥用闭包导致内存溢出，页面卡顿3、JavaScript总共有几种数据类型？字符串、布尔值、数值、undefined、null、object、symbol、bigInt4、JavaScript判断类型的方式是什么？ typeof：只能判断 字符串、布尔值、数值、undefined、function、object、symbol、bigInt，不能区分判断 数组、null、对象 A instanceof B：判断A是否为B的实例对象，从而判断A是否为B类型 Object.prototype.toString.call()：可以判断所有的数据类型6、JavaScript不同类型的存储方式有何区别？普遍认为 基础数据类型存于栈内存 引用数据类型存于堆内存我认为 所有数据都存于堆内存，栈内存只存指针7、你说字符串存储在栈内存，那如果字符串很长。超过了栈内存最大容量呢？所以说我觉得所有数据都存于堆内存，毕竟栈内存容量有限。8、call、apply、bind的区别？ call于apply的区别在于传参，前者直接传参，后者传一个数组 bind传参后不立即执行，而是会返回一个函数，这个函数可以继续传参，且执行（bind函数可以分两次传参）9、bind返回的函数能作为构造函数吗？不能哦，会报错的10、赋值、深拷贝与浅拷贝有什么不同？ 赋值：赋值指针指向，还是用的同一个内存空间 浅拷贝：只拷贝第一层 深拷贝：所有层都会进行拷贝11、怎么判断一个对象有环引用呢？定义一个空数组，且对于目标对象进行递归，每次都判断递归项是否为对象，是的话放进数组，且每次判断属性值是否在数组里，在的话说明环引用了function cycleDetector(obj) { const arr = [obj] let flag = false function cycle(o) { const keys = Object.keys(o) for (const key of keys) { const temp = o[key] if (typeof temp === 'object' &amp;&amp; temp !== null) { if (arr.indexOf(temp) &gt;= 0) { flag = true return } arr.push(temp) cycle(temp) } } } cycle(obj) return flag } ES61、let、const的暂时性死区问题？在一个作用域里如果存在let、const定义的一个变量之前使用该变量，则报错“cannot access xx before initialization” 2、Promise的then为什么可以链式调用？Promise的then方法返回一个新的Promise对象，保证了then方法可以进行链式调用 3、async/await的用法？ async/await的作用是：以同步的方式执行异步操作，实现排队效果 async：async函数执行返回一个Promise await：await后接Promise则会等待Promise返回结果，接普通函数执行则会接收返回结果 await只能在async中使用，但是浏览器调试中await可单独使用4、Class的静态属性、继承？ 静态属性：static关键字定义的变量属性，只能通过Class构造函数的属性的方式去访问 继承：使用 Child extends Father {}，且配合super对象，完成继承Vue 1、Vue与React的区别在哪？比较的是Vue2相同点： 1.都使用了虚拟dom 2.组件化开发 3.都是单向数据流(父子组件之间，不建议子修改父传下来的数据) 4.都支持服务端渲染不同点： 1.React的JSX，Vue的template 2.数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty，Proxy) 3.React单向绑定，Vue双向绑定 4.React的Redux、mobx，Vue的Vuex、pinia 2、computed与watch的区别？ computed：多对一，多个值的变化决定一个目标值的变化 watch：一对多，一个值的变化，引起多个目标值的变化3、Vue的生命周期介绍一下？4、Vue的实例加载完成在哪个生命周期呢？beforeCreated5、Vue的真实dom挂载完成在哪个生命周期呢？mounted6、数据更改如何获取最新DOMnextTick7、路由有几种模式，有何区别？ hash模式：监听url中hash的变化来实现不同页面的展示，链接带# history模式：url中不带#，利用HTML5的history.pushState方法进行不刷新跳转页面，但需要后端配合404时的重定向 abstract：使用在非浏览器的环境，例如node环境8、路由有哪些钩子函数？全局钩子 beforeEach：跳转路由前 to：将要跳转进入的路由对象 from：将要离开的路由对象 next：一个方法，执行则完成跳转 afterEach：跳转路由后 to：将要跳转进入的路由对象 路由独享钩子 routes: [ { path: '/xxx', component: xxx, beforeEnter: (to, from, next) =&gt; { } } ] 组件内路由钩子 beforeRouteEnter(to, from, next)：跳转路由渲染组件时触发 beforeRouteUpdate(to, from, next)：跳转路由且组件被复用时触发 beforeRouteLeave(to, from, next)：跳转路由且离开组件时出触发 转载b站up—林三心","categories":[{"name":"面试","slug":"面试","permalink":"https://largefan.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://largefan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"HTTP","slug":"HTTP","date":"2021-10-08T22:23:11.000Z","updated":"2022-08-29T11:19:33.859Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://largefan.github.io/posts/5.html","excerpt":"","text":"一、什么是HTTP？HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则。即约定, 规则。 二、请求报文（request）：行 包括三部分： 1.请求类型：POST 2.url的路径（写查询字符串、路径）：/s?ie=utf-8 3.（http协议版本）：HTTP/1.1 头 格式为:名字:空格值 Host: baidu.com Cookie: name=baidu Content-type: application/x-www-form-urlencoded User-Agent: chrome 83 空行 体 如果是： get请求：请求体为空 post请求：请求体不为空 username=admin&amp;password=admin 三、响应报文（response）:行 1.（http协议版本）：HTTP/1.1 2.(响应状态码)：200 3.(响应状态字符串):OK 头 Content-Type: text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip 空行 体 返回结果 响应状态码： 200 - 请求成功，已经正常处理完毕 301 - 请求永久重定向，转移到其它URL 302 - 请求临时重定向 304 - 请求被重定向到客户端本地缓存 400 - 客户端请求存在语法错误 401 - 客户端请求没有经过授权 403 - 客户端的请求被服务器拒绝，一般为客户端没有访问权限 404 - 客户端请求的URL在服务端不存在 500 - 服务端永久错误 四、GET响应体控制台查看位置： 五、注意：get没有请求体！ 六、post请求体控制台查看位置：","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://largefan.github.io/tags/HTTP/"}]},{"title":"Ajax的基本使用","slug":"Ajax的基本使用","date":"2021-10-08T21:34:10.000Z","updated":"2022-08-29T11:12:36.798Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://largefan.github.io/posts/4.html","excerpt":"","text":"一、Ajax简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。 AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。 二、XML XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签。 现在已经被 JSON 取代了。 三、Ajax优缺点 Ajax的优点： 可以无需刷新页面而与服务器端进行通信。 允许你根据用户事件来更新部分页面内容。 Ajax的缺点: 没有浏览历史，不能回退 存在跨域问题(同源) SEO 不友好 三、Ajax 的使用XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。 1. 创建 XMLHttpRequest 对象 var xhr = new XMLHttpRequest(); 2. 设置请求信息 xhr.open(method, url); //可以设置请求头，一般不设置 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 3. 发送请求 xhr.send(body) //get 请求不传 body 参数，只有 post 请求使用 4. 接收响应 //xhr.responseXML 接收 xml 格式的响应数据 //xhr.responseText 接收文本格式的响应数据 xhr.onreadystatechange = function (){ if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){ var text = xhr.responseText; console.log(text); } } 四、Ajax请求状态xhr.readyState 可以用来查看请求当前的状态。 介绍 值 状态 描述 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。 3 LOADING 下载中； responseText 属性已经包含部分数据。 4 DONE 下载操作已完成。 0：表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有被调用。 1：open() 方法已经被触发。在这个状态中，可以通过 setRequestHeader() 方法来设置请求的头部。 2：表示 send()方法已经执行，并且头信息和状态码已经收到。 3：表示正在接收服务器传来的 body 部分的数据。（响应体部分正在被接收。如果 responseType 属性是“text”或空字符串， responseText 将会在载入的过程中拥有部分响应数据。） 4： 表示服务器数据已经完全接收，或者本次接收已经失败了。 五、解决 IE 缓存问题 问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。 解决方式：浏览器的缓存是根据 url 地址来记录的，所以我们只需要修改 url 地址即可避免缓存问题。xhr.open(“get”,”/testAJAX?t=”+Date.now());","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://largefan.github.io/tags/Ajax/"}]},{"title":"Gitee配置与注意事项","slug":"Gitee配置与注意事项","date":"2021-10-07T16:00:00.000Z","updated":"2023-02-03T01:27:14.665Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://largefan.github.io/posts/3.html","excerpt":"","text":"Gitee配置一、配置Git操作的用户名、邮箱。1.右键打开Git Bash，输入如下命令： $ git config --global user.name \"你的名字或昵称\" $ git config --global user.email \"你的邮箱\" 二、配置ssh公钥：$ ssh-keygen -t rsa -C \"你的邮箱\" 如果你的电脑输入过这个命令则会出现： Enter file in which to save the key (/c/Users/林子彬/.ssh/id_rsa):/c/Users/林子彬/.ssh/id_rsa already exists.Overwrite (y/n)? 翻译过来就是： 输入保存密钥的文件（/c/Users）/林子彬/.ssh/id_rsa）：/c/用户/林子彬/.ssh/id_rsa已经存在。是否覆盖（是/否）？ 解决方法：直接回车不用管，直接执行第3步。 三、复制生成的SSH key。输入如下命令生成SSH key: $ cat ~/.ssh/id_rsa.pub 四、打开Gitee。主页右上角 「个人设置」-&gt;「安全设置」-&gt;「SSH公钥」-&gt;「添加公钥」 ，复制生成的 public key(公钥)，添加到当前账户中。 五、测试SSH key是否配置ok：$ ssh -T git@gitee.com 返回这个即配置成功： Hi 大风扇! You've successfully authenticated, but GITEE.COM does not provide shell access. Gitee注意事项一、Git的基本操作：$ git add . #将当前目录所有文件添加到git暂存区 $ git commit -m \"my commit\" #提交并备注提交信息 $ git push #将本地提交推送到远程仓库 二、在Gitee上，下载文件：$ git clone git@gitee.com:large-fan/basic-use-of-gitee.git 注意事项： $ git clone + 你想要下载的仓库地址 打开==自己账号==下的仓库，点击 “克隆/下载” 按钮，选择 “SSH”, 点击“复制” 三、上传文件到 Gitee： 如果你想上传文件到gitee仓库，而gitee下载的本地原文件 又被 删除，那么你就只能上gitee把仓库文件下载回本地，然后才能进行上传文件操作（即执行上面的一、代码，即可上传成功）。 四、总结遇到的问题： 下载后找不到该文件，经常在github或gitee上下载文件，但是发现这样git clone下后不知道文件给放哪了？（一般是放解决方法1） 解决方法1：一般情况下会存放在命令行对应的目录下： win + R &gt; cmd 查看命令行地址：C:\\Users\\林子彬&gt; 解决方法2：如果想要改变git后的存放地址，直接cd 改变命令行的地址然后再执行下载命令。 解决方法3：shift+右键，选择打开powershell窗口，然后执行下载命令。 删除问题：把本地仓库里的代码一删除后，码云仓库中的代码也跟着删除了。 解决方法：登录码云代码仓库，点击管理，选择功能设置把禁止仓库同步勾上就行了。","categories":[{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/categories/Git/"}],"tags":[{"name":"Gitee","slug":"Gitee","permalink":"https://largefan.github.io/tags/Gitee/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2021-10-05T16:00:00.000Z","updated":"2023-02-03T01:27:38.272Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://largefan.github.io/posts/2.html","excerpt":"","text":"一、标题标题：（注意#后面要加一个空格！） # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 二、字体斜体字、粗体字、删除内容、短文字： *斜体字* **粗体字** ***斜体加粗体*** ~~删除的内容~~ （1.效果看下面） _下划线_ （2.） `短文字` （3.会有灰色背景） &lt;font color=red&gt;字体颜色代码&lt;/font&gt; 1.我是删除的内容 2.我是下划线 3.短文字 字体颜色代码 三、注释添加注释：（可不加空格） &gt;注释标题 &gt;添加引用内容 &gt;&gt;多级注释 我是标题 我是注释内容 我是多级注释 四、列表无序列表：（必加空格） * 无序列表1 * 无序列表2 * 无序列表2.1（这里按tab键，使层级更加清晰） * 无序列表2.2（这里按tab键，使层级更加清晰） 有序列表：（1.然后空格） 1. 有序列表1 2. 有序列表2 无序： 我是无序列表1 我是无序列表2 我是无序列表2.1 我是无序列表2.2 有序： 我是有序列表1 我是有序列表2 五、复选框复选框：(-然后空格，然后在中括号里面加一个空格，在到外面加空格) - [] 待办事项1 六、分割线分割线： ***或者___ (三个下划线) 七、插入代码插入代码：(三个漂号 或 加上语言类型) ```或```javascript 八、插入图片图片： 方式一： 直接拖进来(图片是存在本地的，别人看你文档是看不到你图片的！) 方式二： ![图片名称](图片地址url) 九、插入网页链接网页链接：先在[]中输入名字,再到括号中输入网址。 [链接某个网页]() 大风扇的博客 十、表格(麻烦，直接右键创建就好了)表格： 标题|标题|标题 :--:|:--|--: 第一个格子|第二个格子|第三个格子 第一个内容|第二个内容|第三个内容 标题 标题 标题 第一个格子 第二个格子 第三个格子 第一个内容 第二个内容 第三个内容 十一、公式公式： $$ 这里写公式 $$ $$2^3+C_2^2=猜一猜？$$ 十二、目录目录： [TOC] [TOC]","categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://largefan.github.io/tags/markdown/"}]},{"title":"hexo + github 搭建个人博客","slug":"hexo + github 搭建个人博客","date":"2021-09-30T16:00:00.000Z","updated":"2023-02-03T01:27:22.157Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://largefan.github.io/posts/1.html","excerpt":"","text":"hexo + github 搭建个人博客1、检查是否安装node、npm、git node -v npm -v git –version 2、Hexo下载 npm install hexo-cli -g hexo -v 3、搭建仓库 仓库名字 要与 账号用户名字一致 4、创建仓库后，生成ssh keys 如未生成过，则在git bash里输入：ssh-keygen -t rsa -C “邮箱地址” 之前已经生成过，如图： 把公钥填入这里 5、本地生成博客内容 在本地创建一个文件夹**(此时里面什么都没)**，右键打开git bash 输入：npm install -g hexo hexo init hexo s &lt;!--启动服务器输入：http://localhost:4000/--&gt; npm run server 6、把博客部署到github deploy: type: git repository: https://github.com/largefan/largefan.github.io.git branch: main 修改完成后，右键打开git bash 安装hexo-deployer-git 自动部署发布工具：npm install hexo-deployer-git –save 建议先 hexo clean 清理一下 然后输入生成页面命令： hexo g 然后把本地文件上传到github仓库 命令：hexo d 然后令牌没问题就可以访问了：https://largefan.github.io/","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://largefan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://largefan.github.io/tags/hexo/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://largefan.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/categories/Git/"},{"name":"面试","slug":"面试","permalink":"https://largefan.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://largefan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://largefan.github.io/tags/ES6/"},{"name":"Node","slug":"Node","permalink":"https://largefan.github.io/tags/Node/"},{"name":"MySQL","slug":"MySQL","permalink":"https://largefan.github.io/tags/MySQL/"},{"name":"Github","slug":"Github","permalink":"https://largefan.github.io/tags/Github/"},{"name":"Git","slug":"Git","permalink":"https://largefan.github.io/tags/Git/"},{"name":"面试","slug":"面试","permalink":"https://largefan.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"HTTP","slug":"HTTP","permalink":"https://largefan.github.io/tags/HTTP/"},{"name":"Ajax","slug":"Ajax","permalink":"https://largefan.github.io/tags/Ajax/"},{"name":"Gitee","slug":"Gitee","permalink":"https://largefan.github.io/tags/Gitee/"},{"name":"markdown","slug":"markdown","permalink":"https://largefan.github.io/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"https://largefan.github.io/tags/hexo/"}]}